\documentclass[a4paper]{article}
\usepackage{url}
\author{Dag Hovland}
\title{Report on the prover \emph{clp}}
\begin{document}
\maketitle
\begin{abstract}
  \emph{clp} (Coherent Logic Prover) is a prover for coherent logic developed by the author. . It takes as input first order logic theories in coherent form. The present report first explains the usage of clp, then turns to a more detailed description of its internals.
\end{abstract}
\section{Usage}
\subsection{Obtaining clp}
The source code of clp can be download from \url{http://code.google.com/p/clp}. It has only been tested on GNU/linux. For compilation it reuired recent versions of bison and flex. It is compiled with the usual configure and make scripts, as describe in the files ``README'' and ``INSTALL''. make all compiles the main executable clp, while make check also compiles clpdebug and clpmemdebug which are used for debugging purposes
\subsection{Running clp}
clp is run from the commandline. An overview of the commandline options is seen when giving the option ``--help''. The name of the file with the coherent theory comes after the options. clp recognizes three different syntaxes for the input, which are chosen by the argument ``--tptp'', ``--CL.pl'', and ``--geolog''. tptp is the format as used by TPTP, but note that the theory must be in coherent form, so only a small subset of actual tptp is supported. CL.pl is a prolog-like format also used by the prover CL.pl by Marc Bezem. This is the default input format. The strategy information supported by CL.pl is though not supported by clp, and is ignored. geolog is the format used by the prover Geolog, by John Fisher.

\subsection{Limiting the Prover}
There are three command-line options for limiting how long the prover runs. If none of these limits are set, the prover runs until it either finds a proof of contradiction, if finds a model of the theory, it runs out of memory or is aborted by other means. ``--wallclocktimer'' limits the number of seconds that may pass from the prover is started until it is halted. ``--cputimer'' limits the number of second of cpu time the prover may use. ``--max'' limits the number of inference steps that may be taken, $0$ means unlimited. The latter is by default set to $300$.

\subsection{Output}
If the ``--verbose'' option is given, the prover outputs information about each step taken. More information may be given by combinations of the ``--debug'' option and uncommenting definitions in ``src/common.h''. 
If the ``--coq'' option is given and a proof is found, the proof is translated to the coq format and output as a ``.v'' file. ``--print\underline{ }model'' prints the model if one is found

The remaining options are mainly for experimenting with different variations of the prover internals. 
\section{Internals of the Prover}

\subsection{Parsing}
Parsing and lexing is done by bison and flex, respectively, and the source code is in the files with suffix .l and .y for the different formats: geolog, clpl and tptp. 

The parser returns a \verb|theory| (defined in theory.h) which contains all the axioms, and also auxiliary information like the names of all variables, constants, function names, and predicates occurring in the theory. 

\subsection{Construction of the RETE network}
The \verb|theory| struct is passed to the function \verb|create|\underline{ }\verb|rete|\underline{ }\verb|net| (together with info about commandline options.) This construction is sketched in other papers, but some points will be noted: The net is accessed by through the struct \verb|rete|\underline{ }\verb|net| defined in rete\underline{ }net.h. The latter structure contains a pointer to each selector (top-level $\alpha$-node) and to each rule-node. In addition information about many command-line switches is stored in this structure. 

\subsection{The Proof Search}
The function \verb|prover|\underline{ }\verb|single| in prover.c represents the proof search itself, and is passed a \verb|rete|\underline{ }\verb|net| as its single argument. The latter is never changed inside this function. Instead, a different struct \verb|rete_state_single| is used to store all iThe \verb|rete|\underline{ }\verb|net| After some initial setup (initializing the fact-set etc.) the function passes control to  \verb|run|\underline{ }\verb|prover|\underline{ }\verb|single| which contains the main loop of the program;: a while-loop which iterates once for each \emph{step} taken by the prover. Each such step starts with determining the next rule instance to apply. This is done by a call to the function \verb|choose_next_instance_single|, which is mainly a wrapper to a call to the function in strategy.c coresponding to the chosen strategy. See more about strategy.c below.

\subsection{Datatypes for logical expressions}
A term is a constant, a variable, or a function applied to a list of terms. Terms are defined in term.h and the functions are in atom\underline{ }and\underline{ }term.c. 

Atoms are defined in atom.h and the functions are in atom\underline{ }and\underline{ }term.c

Initially, the domain is assumed to be exactly the constants appearing in the theory. These are stored in the struct \verb|constants|. When the prover applies existential clauses, new elements may be added to this structure. 

\section{Strategies}
With a strategy for the prover, we mean how the next rule instance application is chosen. The code for this choice is in the function \verb|normal|\underline{ }\verb|next|\underline{ }\verb|instance| in strategy.c. The present strategy is based on some rather intuitive heuristics. \verb|clpl|\underline{ }\verb|next|\underline{ }\verb|instance| implements a depth-first strategy, trying to simulate the strategy used by the prover CL.pl. Adding more strategies should not be hard.



\end{document}